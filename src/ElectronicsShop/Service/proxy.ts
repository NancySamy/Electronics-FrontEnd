/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosBasicCredentials, AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';
import { BaseClientApi, ClientApiConfig } from './Helpers/BaseClientApi';

export interface IElectronicsShopClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    registration(body?: RegisterRequestDto | undefined): Promise<number>;
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginDto | undefined): Promise<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addOrder(body?: AddOrderRequestDto | undefined): Promise<number[]>;
    /**
     * @return Success
     */
    getAllOrders(): Promise<GetOrdersResponseDto>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addProduct(body?: AddProductRequestDto | undefined): Promise<number>;
    /**
     * @return Success
     */
    getAllProducts(): Promise<GetProductsResponseDto>;
    /**
     * @return Success
     */
    getAllCategories(): Promise<GetCategoriesResponseDto>;
}

export class ElectronicsShopClient extends BaseClientApi implements IElectronicsShopClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: ClientApiConfig, baseUrl?: string, instance?: AxiosInstance) {
        super(configuration);
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registration(body?: RegisterRequestDto | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/JwtTokens/Registration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).then((_response: AxiosResponse) => {
            return this.processRegistration(_response);
        });
    }

    protected processRegistration(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/JwtTokens/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrder(body?: AddOrderRequestDto | undefined): Promise<number[]> {
        let url_ = this.baseUrl + "/api/Order/AddOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).then((_response: AxiosResponse) => {
            return this.processAddOrder(_response);
        });
    }

    protected processAddOrder(response: AxiosResponse): Promise<number[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllOrders(): Promise<GetOrdersResponseDto> {
        let url_ = this.baseUrl + "/api/Order/GetAllOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).then((_response: AxiosResponse) => {
            return this.processGetAllOrders(_response);
        });
    }

    protected processGetAllOrders(response: AxiosResponse): Promise<GetOrdersResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetOrdersResponseDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrdersResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addProduct(body?: AddProductRequestDto | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Product/AddProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).then((_response: AxiosResponse) => {
            return this.processAddProduct(_response);
        });
    }

    protected processAddProduct(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAllProducts(): Promise<GetProductsResponseDto> {
        let url_ = this.baseUrl + "/api/Product/GetAllProducts";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).then((_response: AxiosResponse) => {
            return this.processGetAllProducts(_response);
        });
    }

    protected processGetAllProducts(response: AxiosResponse): Promise<GetProductsResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetProductsResponseDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetProductsResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCategories(): Promise<GetCategoriesResponseDto> {
        let url_ = this.baseUrl + "/api/Product/GetAllCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).then((_response: AxiosResponse) => {
            return this.processGetAllCategories(_response);
        });
    }

    protected processGetAllCategories(response: AxiosResponse): Promise<GetCategoriesResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetCategoriesResponseDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetCategoriesResponseDto>(<any>null);
    }
}

export class AddOrderRequestDto implements IAddOrderRequestDto {
    userID!: number;
    orderProducts!: OrderRequestDto[] | undefined;

    constructor(data?: IAddOrderRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userID = _data["UserID"];
            if (Array.isArray(_data["OrderProducts"])) {
                this.orderProducts = [] as any;
                for (let item of _data["OrderProducts"])
                    this.orderProducts!.push(OrderRequestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrderRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrderRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserID"] = this.userID;
        if (Array.isArray(this.orderProducts)) {
            data["OrderProducts"] = [];
            for (let item of this.orderProducts)
                data["OrderProducts"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AddOrderRequestDto {
        const json = this.toJSON();
        let result = new AddOrderRequestDto();
        result.init(json);
        return result;
    }
}

export interface IAddOrderRequestDto {
    userID: number;
    orderProducts: OrderRequestDto[] | undefined;
}

export class AddProductRequestDto implements IAddProductRequestDto {
    nameAr!: string | undefined;
    nameEn!: string | undefined;
    descAr!: string | undefined;
    descEn!: string | undefined;
    price!: number;
    categoryId!: CategoryTypes;
    discountPercentage!: number;
    quantity!: number;

    constructor(data?: IAddProductRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameAr = _data["NameAr"];
            this.nameEn = _data["NameEn"];
            this.descAr = _data["DescAr"];
            this.descEn = _data["DescEn"];
            this.price = _data["Price"];
            this.categoryId = _data["CategoryId"];
            this.discountPercentage = _data["DiscountPercentage"];
            this.quantity = _data["Quantity"];
        }
    }

    static fromJS(data: any): AddProductRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddProductRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NameAr"] = this.nameAr;
        data["NameEn"] = this.nameEn;
        data["DescAr"] = this.descAr;
        data["DescEn"] = this.descEn;
        data["Price"] = this.price;
        data["CategoryId"] = this.categoryId;
        data["DiscountPercentage"] = this.discountPercentage;
        data["Quantity"] = this.quantity;
        return data; 
    }

    clone(): AddProductRequestDto {
        const json = this.toJSON();
        let result = new AddProductRequestDto();
        result.init(json);
        return result;
    }
}

export interface IAddProductRequestDto {
    nameAr: string | undefined;
    nameEn: string | undefined;
    descAr: string | undefined;
    descEn: string | undefined;
    price: number;
    categoryId: CategoryTypes;
    discountPercentage: number;
    quantity: number;
}

export class CategoryDto implements ICategoryDto {
    id!: number;
    nameAr!: string | undefined;
    nameEn!: string | undefined;
    code!: string | undefined;
    descAr!: string | undefined;
    descEn!: string | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.nameAr = _data["NameAr"];
            this.nameEn = _data["NameEn"];
            this.code = _data["Code"];
            this.descAr = _data["DescAr"];
            this.descEn = _data["DescEn"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["NameAr"] = this.nameAr;
        data["NameEn"] = this.nameEn;
        data["Code"] = this.code;
        data["DescAr"] = this.descAr;
        data["DescEn"] = this.descEn;
        return data; 
    }

    clone(): CategoryDto {
        const json = this.toJSON();
        let result = new CategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryDto {
    id: number;
    nameAr: string | undefined;
    nameEn: string | undefined;
    code: string | undefined;
    descAr: string | undefined;
    descEn: string | undefined;
}

export enum CategoryTypes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class GetCategoriesResponseDto implements IGetCategoriesResponseDto {
    categories!: CategoryDto[] | undefined;

    constructor(data?: IGetCategoriesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Categories"])) {
                this.categories = [] as any;
                for (let item of _data["Categories"])
                    this.categories!.push(CategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCategoriesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoriesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categories)) {
            data["Categories"] = [];
            for (let item of this.categories)
                data["Categories"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetCategoriesResponseDto {
        const json = this.toJSON();
        let result = new GetCategoriesResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetCategoriesResponseDto {
    categories: CategoryDto[] | undefined;
}

export class GetOrdersResponseDto implements IGetOrdersResponseDto {
    orders!: OrderDto[] | undefined;

    constructor(data?: IGetOrdersResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Orders"])) {
                this.orders = [] as any;
                for (let item of _data["Orders"])
                    this.orders!.push(OrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetOrdersResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrdersResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orders)) {
            data["Orders"] = [];
            for (let item of this.orders)
                data["Orders"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetOrdersResponseDto {
        const json = this.toJSON();
        let result = new GetOrdersResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetOrdersResponseDto {
    orders: OrderDto[] | undefined;
}

export class GetProductsResponseDto implements IGetProductsResponseDto {
    products!: ProductsDto[] | undefined;

    constructor(data?: IGetProductsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Products"])) {
                this.products = [] as any;
                for (let item of _data["Products"])
                    this.products!.push(ProductsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["Products"] = [];
            for (let item of this.products)
                data["Products"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetProductsResponseDto {
        const json = this.toJSON();
        let result = new GetProductsResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetProductsResponseDto {
    products: ProductsDto[] | undefined;
}

export class LoginDto implements ILoginDto {
    password!: string | undefined;
    email!: string | undefined;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["Password"];
            this.email = _data["Email"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Password"] = this.password;
        data["Email"] = this.email;
        return data; 
    }

    clone(): LoginDto {
        const json = this.toJSON();
        let result = new LoginDto();
        result.init(json);
        return result;
    }
}

export interface ILoginDto {
    password: string | undefined;
    email: string | undefined;
}

export class OrderDto implements IOrderDto {
    userID!: number;
    productID!: number;
    quantity!: number;
    finalPrice!: number;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userID = _data["UserID"];
            this.productID = _data["ProductID"];
            this.quantity = _data["Quantity"];
            this.finalPrice = _data["FinalPrice"];
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserID"] = this.userID;
        data["ProductID"] = this.productID;
        data["Quantity"] = this.quantity;
        data["FinalPrice"] = this.finalPrice;
        return data; 
    }

    clone(): OrderDto {
        const json = this.toJSON();
        let result = new OrderDto();
        result.init(json);
        return result;
    }
}

export interface IOrderDto {
    userID: number;
    productID: number;
    quantity: number;
    finalPrice: number;
}

export class OrderRequestDto implements IOrderRequestDto {
    productID!: number;
    quantity!: number;

    constructor(data?: IOrderRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productID = _data["ProductID"];
            this.quantity = _data["Quantity"];
        }
    }

    static fromJS(data: any): OrderRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProductID"] = this.productID;
        data["Quantity"] = this.quantity;
        return data; 
    }

    clone(): OrderRequestDto {
        const json = this.toJSON();
        let result = new OrderRequestDto();
        result.init(json);
        return result;
    }
}

export interface IOrderRequestDto {
    productID: number;
    quantity: number;
}

export class ProductsDto implements IProductsDto {
    nameAr!: string | undefined;
    nameEn!: string | undefined;
    descAr!: string | undefined;
    descEn!: string | undefined;
    price!: number;
    categoryId!: number;
    Id!: number;
    discountPercentage!: number;
    quantity!: number;

    constructor(data?: IProductsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameAr = _data["NameAr"];
            this.nameEn = _data["NameEn"];
            this.descAr = _data["DescAr"];
            this.descEn = _data["DescEn"];
            this.price = _data["Price"];
            this.categoryId = _data["CategoryId"];
            this.Id = _data["Id"];
            this.discountPercentage = _data["DiscountPercentage"];
            this.quantity = _data["Quantity"];
        }
    }

    static fromJS(data: any): ProductsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.Id;
        data["NameAr"] = this.nameAr;
        data["NameEn"] = this.nameEn;
        data["DescAr"] = this.descAr;
        data["DescEn"] = this.descEn;
        data["Price"] = this.price;
        data["CategoryId"] = this.categoryId;
        data["DiscountPercentage"] = this.discountPercentage;
        data["Quantity"] = this.quantity;
        return data; 
    }

    clone(): ProductsDto {
        const json = this.toJSON();
        let result = new ProductsDto();
        result.init(json);
        return result;
    }
}

export interface IProductsDto {
    nameAr: string | undefined;
    nameEn: string | undefined;
    descAr: string | undefined;
    descEn: string | undefined;
    price: number;
    categoryId: number;
    Id: number;
    discountPercentage: number;
    quantity: number;
}

export class RegisterRequestDto implements IRegisterRequestDto {
    userName!: string | undefined;
    address!: string | undefined;
    email!: string | undefined;
    phoneNumber!: string | undefined;
    birthDate!: Date|string| undefined;
    password!: string | undefined;

    constructor(data?: IRegisterRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            this.address = _data["Address"];
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
            this.birthDate = _data["BirthDate"] ? new Date(_data["BirthDate"].toString()) : <any>undefined;
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): RegisterRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["Address"] = this.address;
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["BirthDate"] = this.birthDate ? this.birthDate : <any>undefined;
        data["Password"] = this.password;
        return data; 
    }

    clone(): RegisterRequestDto {
        const json = this.toJSON();
        let result = new RegisterRequestDto();
        result.init(json);
        return result;
    }
}

export interface IRegisterRequestDto {
    userName: string | undefined;
    address: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    birthDate: Date|string| undefined;
    password: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}